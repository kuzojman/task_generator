# -*- coding: utf-8 -*-
"""bezier_line_1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1nJcwfyEqkNQP-IT8IAqA4mviApK8FSIM
"""

import random
import bezier
import numpy as np
import math
import fractions
from sympy import *
import matplotlib.pyplot as plt
import re
import time
from utilities.converting import save_to_base64


def plot_curve_bezier_and_line():
    x = Symbol('x')
    n_1 = random.randint(20, 30)
    x_start = random.randint(-9, -6)
    x_end = random.randint(2, 17)
    while True:
        x1 = np.random.randint(x_start, x_end)
        y1 = np.random.randint(-8, 8)
        x2 = np.random.randint(x_start, x_end)
        while x2 == x1:
            x2 = np.random.randint(-10, 10)
        y2 = np.random.randint(-8, 8)
        while y2 == y1:
            y2 = np.random.randint(-8, 8)
        frac = Rational(y2 - y1, x2 - x1)
        if frac.is_finite and ask(Q.integer(frac * 10000)) is True:
            break
    k = (y2 - y1) / (x2 - x1)
    x0 = np.random.uniform(x1, x2)
    while x0 == x1 or x0 == x2:
        x0 = np.random.uniform(x1, x2)
    b = y1 - k * x1
    while True:
        outer_start_time = time.time()
        while True:
            inner_start_time = time.time()
            x_arr = sorted(np.random.uniform(x_start, x_end, n_1))
            y_arr = np.random.uniform(-15, 15, n_1)
            nodes1 = np.asfortranarray([[x_start, *x_arr, x_end + 1], [1.0, *y_arr, 1.0]])
            curve1 = bezier.Curve(nodes1, degree=n_1 + 1)
            t_values = np.linspace(0.0, 1, 1000000)
            points = curve1.evaluate_multi(t_values)
            x_bezier, y_bezier = points[0], points[1]
            x_01 = []
            for i in range(1, len(x_bezier)):
                if abs((y_bezier[i] - y_bezier[i - 1])/(x_bezier[i] - x_bezier[i - 1]) - k) < 0.0005:
                    x_01.append((x_bezier[i], y_bezier[i]))
            if len(x_01) > 0:
                break
            inner_end_time = time.time()
            if inner_end_time - inner_start_time > 9:
                continue
        point = random.choice(x_01)
        offset = (k * point[0] + b) - point[1]
        nodes1[1] += offset
        x0 = point[0]
        curve1 = bezier.Curve(nodes1, degree=n_1 + 1)
        if -11 + offset < y1 < 11 + offset and -11 + offset < y2 < 11 + offset:
            break
        outer_end_time = time.time()
        if outer_end_time - outer_start_time > 14:
            continue
    curve_tangent = k * x + b
    y0 = curve_tangent.subs(x, x0)
    list_y = [0, y0, y1, y2, min(points[1]) + offset, max(points[1]) + offset]
    curve_tangent_fn = lambdify(x, curve_tangent, 'numpy')
    x_vals = np.linspace(-25, 25, 20000)
    y_vals_tangent = curve_tangent_fn(x_vals)
    ax = curve1.plot(num_pts=2456)
    ax.spines[["left", "bottom"]].set_position('zero')
    ax.spines[["top", "right"]].set_visible(False)
    ax.plot(1, 0, ">k", transform=ax.get_yaxis_transform(), clip_on=False)
    ax.plot(0, 1, "^k", transform=ax.get_xaxis_transform(), clip_on=False)
    arrow_length = 10
    ax.annotate('x', xy=(1, 0), xycoords=('axes fraction', 'data'),
                xytext=(0, arrow_length), textcoords='offset points',
                ha='center', va='bottom')
    ax.annotate('y', xy=(0, 1), xycoords=('data', 'axes fraction'),
                xytext=(arrow_length, 0), textcoords='offset points',
                ha='center', va='bottom')
    plt.axhline(color='black')
    plt.axvline(color='black')
    plt.grid(True, linewidth=0.5, linestyle='dotted')
    plt.axis('equal')
    ax.set_xticks(range(x_start - 9, x_end + 13))
    ax.set_yticks(range(-17 + int(offset), 17 + int(offset)))
    ax.set_xticklabels([i if i % 2 == 0 else '' for i in range(x_start - 9, x_end + 13)])
    ax.set_yticklabels([i if i % 2 == 0 else '' for i in range(-17 + int(offset), 17 + int(offset))])
    plt.xlim(x_start - 1, x_end + 2)
    plt.ylim(min(list_y) - 1, max(list_y) + 1)
    plt.scatter(x1, y1, color='green', label='')
    plt.scatter(x2, y2, color='green', label='')
    plt.plot(x_vals, y_vals_tangent, color='purple', label='tangent')
    plt.scatter(x0, y0, color='red', label='')
    plt.plot([x0, x0], [y0, 0], ':', color='red')
    plt.text(x0, 0, "x\u2092", ha='center', va='bottom')
    plt.title('')
    plt.legend(labels=["y = f(x)"])
    plt_base64 = save_to_base64(plt)
    plt.close()
    task = r'Найдите значение производной функции f(x) в точке ' + r"\(x_0 \)"
    answer = float(k)
    return {
        "condition": task,
        "answer": answer,
        "image": plt_base64,
        }
